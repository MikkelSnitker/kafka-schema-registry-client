/*
 * Confluent Schema Registry
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`delete_schema_version`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSchemaVersionError {
    Status404(models::ErrorMessage),
    Status422(models::ErrorMessage),
    Status500(models::ErrorMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_subject`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSubjectError {
    Status404(models::ErrorMessage),
    Status500(models::ErrorMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_referenced_by`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetReferencedByError {
    Status404(models::ErrorMessage),
    Status422(models::ErrorMessage),
    Status500(models::ErrorMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_schema_by_version`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSchemaByVersionError {
    Status404(models::ErrorMessage),
    Status422(models::ErrorMessage),
    Status500(models::ErrorMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_schema_only2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSchemaOnly2Error {
    Status404(models::ErrorMessage),
    Status422(models::ErrorMessage),
    Status500(models::ErrorMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListError {
    Status500(models::ErrorMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_versions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListVersionsError {
    Status404(models::ErrorMessage),
    Status500(models::ErrorMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`look_up_schema_under_subject`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LookUpSchemaUnderSubjectError {
    Status404(models::ErrorMessage),
    Status500(models::ErrorMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`register`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RegisterError {
    Status409(models::ErrorMessage),
    Status422(models::ErrorMessage),
    Status500(models::ErrorMessage),
    UnknownValue(serde_json::Value),
}


/// Deletes a specific version of the schema registered under this subject. This only deletes the version and the schema ID remains intact making it still possible to decode data using the schema ID. This API is recommended to be used only in development environments or under extreme circumstances where-in, its required to delete a previously registered schema for compatibility purposes or re-register previously registered schema.
pub async fn delete_schema_version(configuration: &configuration::Configuration, subject: &str, version: &str, permanent: Option<bool>) -> Result<i32, Error<DeleteSchemaVersionError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/subjects/{subject}/versions/{version}", local_var_configuration.base_path, subject=crate::apis::urlencode(subject), version=crate::apis::urlencode(version));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = permanent {
        local_var_req_builder = local_var_req_builder.query(&[("permanent", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteSchemaVersionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deletes the specified subject and its associated compatibility level if registered. It is recommended to use this API only when a topic needs to be recycled or in development environment.
pub async fn delete_subject(configuration: &configuration::Configuration, subject: &str, permanent: Option<bool>) -> Result<Vec<i32>, Error<DeleteSubjectError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/subjects/{subject}", local_var_configuration.base_path, subject=crate::apis::urlencode(subject));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = permanent {
        local_var_req_builder = local_var_req_builder.query(&[("permanent", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteSubjectError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieves the IDs of schemas that reference the specified schema.
pub async fn get_referenced_by(configuration: &configuration::Configuration, subject: &str, version: &str) -> Result<Vec<i32>, Error<GetReferencedByError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/subjects/{subject}/versions/{version}/referencedby", local_var_configuration.base_path, subject=crate::apis::urlencode(subject), version=crate::apis::urlencode(version));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetReferencedByError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieves a specific version of the schema registered under this subject.
pub async fn get_schema_by_version(configuration: &configuration::Configuration, subject: &str, version: &str, deleted: Option<bool>) -> Result<models::Schema, Error<GetSchemaByVersionError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/subjects/{subject}/versions/{version}", local_var_configuration.base_path, subject=crate::apis::urlencode(subject), version=crate::apis::urlencode(version));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = deleted {
        local_var_req_builder = local_var_req_builder.query(&[("deleted", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetSchemaByVersionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieves the schema for the specified version of this subject. Only the unescaped schema string is returned.
pub async fn get_schema_only2(configuration: &configuration::Configuration, subject: &str, version: &str, deleted: Option<bool>) -> Result<String, Error<GetSchemaOnly2Error>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/subjects/{subject}/versions/{version}/schema", local_var_configuration.base_path, subject=crate::apis::urlencode(subject), version=crate::apis::urlencode(version));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = deleted {
        local_var_req_builder = local_var_req_builder.query(&[("deleted", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetSchemaOnly2Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieves a list of registered subjects matching specified parameters.
pub async fn list(configuration: &configuration::Configuration, subject_prefix: Option<&str>, deleted: Option<bool>, deleted_only: Option<bool>) -> Result<Vec<String>, Error<ListError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/subjects", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = subject_prefix {
        local_var_req_builder = local_var_req_builder.query(&[("subjectPrefix", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = deleted {
        local_var_req_builder = local_var_req_builder.query(&[("deleted", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = deleted_only {
        local_var_req_builder = local_var_req_builder.query(&[("deletedOnly", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieves a list of versions registered under the specified subject.
pub async fn list_versions(configuration: &configuration::Configuration, subject: &str, deleted: Option<bool>, deleted_only: Option<bool>) -> Result<Vec<i32>, Error<ListVersionsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/subjects/{subject}/versions", local_var_configuration.base_path, subject=crate::apis::urlencode(subject));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = deleted {
        local_var_req_builder = local_var_req_builder.query(&[("deleted", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = deleted_only {
        local_var_req_builder = local_var_req_builder.query(&[("deletedOnly", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListVersionsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Check if a schema has already been registered under the specified subject. If so, this returns the schema string along with its globally unique identifier, its version under this subject and the subject name.
pub async fn look_up_schema_under_subject(configuration: &configuration::Configuration, subject: &str, register_schema_request: models::RegisterSchemaRequest, normalize: Option<bool>, deleted: Option<bool>) -> Result<models::Schema, Error<LookUpSchemaUnderSubjectError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/subjects/{subject}", local_var_configuration.base_path, subject=crate::apis::urlencode(subject));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = normalize {
        local_var_req_builder = local_var_req_builder.query(&[("normalize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = deleted {
        local_var_req_builder = local_var_req_builder.query(&[("deleted", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&register_schema_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<LookUpSchemaUnderSubjectError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Register a new schema under the specified subject. If successfully registered, this returns the unique identifier of this schema in the registry. The returned identifier should be used to retrieve this schema from the schemas resource and is different from the schema's version which is associated with the subject. If the same schema is registered under a different subject, the same identifier will be returned. However, the version of the schema may be different under different subjects. A schema should be compatible with the previously registered schema or schemas (if there are any) as per the configured compatibility level. The configured compatibility level can be obtained by issuing a GET http:get:: /config/(string: subject). If that returns null, then GET http:get:: /config When there are multiple instances of Schema Registry running in the same cluster, the schema registration request will be forwarded to one of the instances designated as the primary. If the primary is not available, the client will get an error code indicating that the forwarding has failed.
pub async fn register(configuration: &configuration::Configuration, subject: &str, register_schema_request: models::RegisterSchemaRequest, normalize: Option<bool>) -> Result<models::RegisterSchemaResponse, Error<RegisterError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/subjects/{subject}/versions", local_var_configuration.base_path, subject=crate::apis::urlencode(subject));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = normalize {
        local_var_req_builder = local_var_req_builder.query(&[("normalize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&register_schema_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RegisterError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

