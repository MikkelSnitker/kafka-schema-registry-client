/*
 * Confluent Schema Registry
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`test_compatibility_by_subject_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TestCompatibilityBySubjectNameError {
    Status404(models::ErrorMessage),
    Status422(models::ErrorMessage),
    Status500(models::ErrorMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`test_compatibility_for_subject`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TestCompatibilityForSubjectError {
    Status422(models::ErrorMessage),
    Status500(models::ErrorMessage),
    UnknownValue(serde_json::Value),
}


/// Test input schema against a particular version of a subject's schema for compatibility. The compatibility level applied for the check is the configured compatibility level for the subject (http:get:: /config/(string: subject)). If this subject's compatibility level was never changed, then the global compatibility level applies (http:get:: /config).
pub async fn test_compatibility_by_subject_name(configuration: &configuration::Configuration, subject: &str, version: &str, register_schema_request: models::RegisterSchemaRequest, normalize: Option<bool>, verbose: Option<bool>) -> Result<models::CompatibilityCheckResponse, Error<TestCompatibilityBySubjectNameError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/compatibility/subjects/{subject}/versions/{version}", local_var_configuration.base_path, subject=crate::apis::urlencode(subject), version=crate::apis::urlencode(version));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = normalize {
        local_var_req_builder = local_var_req_builder.query(&[("normalize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = verbose {
        local_var_req_builder = local_var_req_builder.query(&[("verbose", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&register_schema_request);

    if let Some((username, password)) = local_var_configuration.basic_auth.clone() {
        local_var_req_builder.basic_auth(username, password);
    }   

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TestCompatibilityBySubjectNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Test input schema against a subject's schemas for compatibility, based on the configured compatibility level of the subject. In other words, it will perform the same compatibility check as register for that subject. The compatibility level applied for the check is the configured compatibility level for the subject (http:get:: /config/(string: subject)). If this subject's compatibility level was never changed, then the global compatibility level applies (http:get:: /config).
pub async fn test_compatibility_for_subject(configuration: &configuration::Configuration, subject: &str, register_schema_request: models::RegisterSchemaRequest, normalize: Option<bool>, verbose: Option<bool>) -> Result<models::CompatibilityCheckResponse, Error<TestCompatibilityForSubjectError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/compatibility/subjects/{subject}/versions", local_var_configuration.base_path, subject=crate::apis::urlencode(subject));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = normalize {
        local_var_req_builder = local_var_req_builder.query(&[("normalize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = verbose {
        local_var_req_builder = local_var_req_builder.query(&[("verbose", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&register_schema_request);

    if let Some((username, password)) = local_var_configuration.basic_auth.clone() {
        local_var_req_builder.basic_auth(username, password);
    }   
    
    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TestCompatibilityForSubjectError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

